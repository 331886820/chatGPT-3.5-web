"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-client)/./app/constant.ts":
/*!*************************!*\
  !*** ./app/constant.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FETCH_COMMIT_URL\": function() { return /* binding */ FETCH_COMMIT_URL; },\n/* harmony export */   \"FETCH_TAG_URL\": function() { return /* binding */ FETCH_TAG_URL; },\n/* harmony export */   \"ISSUE_URL\": function() { return /* binding */ ISSUE_URL; },\n/* harmony export */   \"OWNER\": function() { return /* binding */ OWNER; },\n/* harmony export */   \"REPO\": function() { return /* binding */ REPO; },\n/* harmony export */   \"REPO_URL\": function() { return /* binding */ REPO_URL; },\n/* harmony export */   \"UPDATE_URL\": function() { return /* binding */ UPDATE_URL; }\n/* harmony export */ });\nconst OWNER = \"331886820\";\nconst REPO = \"ChatGPT-健康版\";\nconst REPO_URL = \"https://github.com/\".concat(OWNER, \"/\").concat(REPO);\nconst ISSUE_URL = \"https://github.com/\".concat(OWNER, \"/\").concat(REPO, \"/issues\");\nconst UPDATE_URL = \"\".concat(REPO_URL, \"#keep-updated\");\nconst FETCH_COMMIT_URL = \"https://api.github.com/repos/\".concat(OWNER, \"/\").concat(REPO, \"/commits?per_page=1\");\nconst FETCH_TAG_URL = \"https://api.github.com/repos/\".concat(OWNER, \"/\").concat(REPO, \"/tags?per_page=1\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbnN0YW50LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxRQUFRLFlBQVk7QUFDMUIsTUFBTUMsT0FBTyxjQUFjO0FBQzNCLE1BQU1DLFdBQVcsc0JBQStCRCxPQUFURCxPQUFNLEtBQVEsT0FBTEMsTUFBTztBQUN2RCxNQUFNRSxZQUFZLHNCQUErQkYsT0FBVEQsT0FBTSxLQUFRLE9BQUxDLE1BQUssV0FBUztBQUMvRCxNQUFNRyxhQUFhLEdBQVksT0FBVEYsVUFBUyxpQkFBZTtBQUM5QyxNQUFNRyxtQkFBbUIsZ0NBQXlDSixPQUFURCxPQUFNLEtBQVEsT0FBTEMsTUFBSyx1QkFBcUI7QUFDNUYsTUFBTUssZ0JBQWdCLGdDQUF5Q0wsT0FBVEQsT0FBTSxLQUFRLE9BQUxDLE1BQUssb0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb25zdGFudC50cz9hZjQ0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBPV05FUiA9IFwiMzMxODg2ODIwXCI7XHJcbmV4cG9ydCBjb25zdCBSRVBPID0gXCJDaGF0R1BULeWBpeW6t+eJiFwiO1xyXG5leHBvcnQgY29uc3QgUkVQT19VUkwgPSBgaHR0cHM6Ly9naXRodWIuY29tLyR7T1dORVJ9LyR7UkVQT31gO1xyXG5leHBvcnQgY29uc3QgSVNTVUVfVVJMID0gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke09XTkVSfS8ke1JFUE99L2lzc3Vlc2A7XHJcbmV4cG9ydCBjb25zdCBVUERBVEVfVVJMID0gYCR7UkVQT19VUkx9I2tlZXAtdXBkYXRlZGA7XHJcbmV4cG9ydCBjb25zdCBGRVRDSF9DT01NSVRfVVJMID0gYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtPV05FUn0vJHtSRVBPfS9jb21taXRzP3Blcl9wYWdlPTFgO1xyXG5leHBvcnQgY29uc3QgRkVUQ0hfVEFHX1VSTCA9IGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7T1dORVJ9LyR7UkVQT30vdGFncz9wZXJfcGFnZT0xYDtcclxuIl0sIm5hbWVzIjpbIk9XTkVSIiwiUkVQTyIsIlJFUE9fVVJMIiwiSVNTVUVfVVJMIiwiVVBEQVRFX1VSTCIsIkZFVENIX0NPTU1JVF9VUkwiLCJGRVRDSF9UQUdfVVJMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./app/constant.ts\n"));

/***/ }),

/***/ "(app-client)/./app/requests.ts":
/*!*************************!*\
  !*** ./app/requests.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ControllerPool\": function() { return /* binding */ ControllerPool; },\n/* harmony export */   \"requestChat\": function() { return /* binding */ requestChat; },\n/* harmony export */   \"requestChatStream\": function() { return /* binding */ requestChatStream; },\n/* harmony export */   \"requestOpenaiClient\": function() { return /* binding */ requestOpenaiClient; },\n/* harmony export */   \"requestUsage\": function() { return /* binding */ requestUsage; },\n/* harmony export */   \"requestWithPrompt\": function() { return /* binding */ requestWithPrompt; }\n/* harmony export */ });\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store */ \"(app-client)/./app/store/index.ts\");\n/* harmony import */ var _components_ui_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/ui-lib */ \"(app-client)/./app/components/ui-lib.tsx\");\n\n\nconst TIME_OUT_MS = 30000;\nconst makeRequestParam = (messages, options)=>{\n    let sendMessages = messages.map((v)=>({\n            role: v.role,\n            content: v.content\n        }));\n    if (options === null || options === void 0 ? void 0 : options.filterBot) {\n        sendMessages = sendMessages.filter((m)=>m.role !== \"assistant\");\n    }\n    const modelConfig = {\n        ..._store__WEBPACK_IMPORTED_MODULE_0__.useChatStore.getState().config.modelConfig\n    };\n    // @331886820: wont send max_tokens, because it is nonsense for Muggles\n    // @ts-expect-error\n    delete modelConfig.max_tokens;\n    return {\n        messages: sendMessages,\n        stream: options === null || options === void 0 ? void 0 : options.stream,\n        ...modelConfig\n    };\n};\nfunction getHeaders() {\n    const accessStore = _store__WEBPACK_IMPORTED_MODULE_0__.useAccessStore.getState();\n    let headers = {};\n    if (accessStore.enabledAccessControl()) {\n        headers[\"access-code\"] = accessStore.accessCode;\n    }\n    if (accessStore.token && accessStore.token.length > 0) {\n        headers[\"token\"] = accessStore.token;\n    }\n    return headers;\n}\nfunction requestOpenaiClient(path) {\n    return function(body) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"POST\";\n        return fetch(\"/api/openai?_vercel_no_cache=1\", {\n            method,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                path,\n                ...getHeaders()\n            },\n            body: body && JSON.stringify(body)\n        });\n    };\n}\nasync function requestChat(messages) {\n    const req = makeRequestParam(messages, {\n        filterBot: true\n    });\n    const res = await requestOpenaiClient(\"v1/chat/completions\")(req);\n    try {\n        const response = await res.json();\n        return response;\n    } catch (error) {\n        console.error(\"[Request Chat] \", error, res.body);\n    }\n}\nasync function requestUsage() {\n    const formatDate = (d)=>\"\".concat(d.getFullYear(), \"-\").concat((d.getMonth() + 1).toString().padStart(2, \"0\"), \"-\").concat(d.getDate().toString().padStart(2, \"0\"));\n    const ONE_DAY = 2 * 24 * 60 * 60 * 1000;\n    const now = new Date(Date.now() + ONE_DAY);\n    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n    const startDate = formatDate(startOfMonth);\n    const endDate = formatDate(now);\n    const [used, subs] = await Promise.all([\n        requestOpenaiClient(\"dashboard/billing/usage?start_date=\".concat(startDate, \"&end_date=\").concat(endDate))(null, \"GET\"),\n        requestOpenaiClient(\"dashboard/billing/subscription\")(null, \"GET\")\n    ]);\n    const response = await used.json();\n    const total = await subs.json();\n    if (response.error && response.error.type) {\n        (0,_components_ui_lib__WEBPACK_IMPORTED_MODULE_1__.showToast)(response.error.message);\n        return;\n    }\n    if (response.total_usage) {\n        response.total_usage = Math.round(response.total_usage) / 100;\n    }\n    return {\n        used: response.total_usage,\n        subscription: total.hard_limit_usd\n    };\n}\nasync function requestChatStream(messages, options) {\n    const req = makeRequestParam(messages, {\n        stream: true,\n        filterBot: options === null || options === void 0 ? void 0 : options.filterBot\n    });\n    console.log(\"[Request] \", req);\n    const controller = new AbortController();\n    const reqTimeoutId = setTimeout(()=>controller.abort(), TIME_OUT_MS);\n    try {\n        const res = await fetch(\"/api/chat-stream\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                path: \"v1/chat/completions\",\n                ...getHeaders()\n            },\n            body: JSON.stringify(req),\n            signal: controller.signal\n        });\n        clearTimeout(reqTimeoutId);\n        let responseText = \"\";\n        const finish = ()=>{\n            options === null || options === void 0 ? void 0 : options.onMessage(responseText, true);\n            controller.abort();\n        };\n        if (res.ok) {\n            var _res_body, _options_onController;\n            const reader = (_res_body = res.body) === null || _res_body === void 0 ? void 0 : _res_body.getReader();\n            const decoder = new TextDecoder();\n            options === null || options === void 0 ? void 0 : (_options_onController = options.onController) === null || _options_onController === void 0 ? void 0 : _options_onController.call(options, controller);\n            while(true){\n                // handle time out, will stop if no response in 10 secs\n                const resTimeoutId = setTimeout(()=>finish(), TIME_OUT_MS);\n                const content = await (reader === null || reader === void 0 ? void 0 : reader.read());\n                clearTimeout(resTimeoutId);\n                const text = decoder.decode(content === null || content === void 0 ? void 0 : content.value);\n                responseText += text;\n                const done = !content || content.done;\n                options === null || options === void 0 ? void 0 : options.onMessage(responseText, false);\n                if (done) {\n                    break;\n                }\n            }\n            finish();\n        } else if (res.status === 401) {\n            console.error(\"Anauthorized\");\n            options === null || options === void 0 ? void 0 : options.onError(new Error(\"Anauthorized\"), res.status);\n        } else {\n            console.error(\"Stream Error\", res.body);\n            options === null || options === void 0 ? void 0 : options.onError(new Error(\"Stream Error\"), res.status);\n        }\n    } catch (err) {\n        console.error(\"NetWork Error\", err);\n        options === null || options === void 0 ? void 0 : options.onError(err);\n    }\n}\nasync function requestWithPrompt(messages, prompt) {\n    var _res_choices_at, _res_choices, _res_choices_at_message;\n    messages = messages.concat([\n        {\n            role: \"user\",\n            content: prompt,\n            date: new Date().toLocaleString()\n        }\n    ]);\n    const res = await requestChat(messages);\n    var _res_choices_at_message_content;\n    return (_res_choices_at_message_content = (_res_choices_at = res === null || res === void 0 ? void 0 : (_res_choices = res.choices) === null || _res_choices === void 0 ? void 0 : _res_choices.at(0)) === null || _res_choices_at === void 0 ? void 0 : (_res_choices_at_message = _res_choices_at.message) === null || _res_choices_at_message === void 0 ? void 0 : _res_choices_at_message.content) !== null && _res_choices_at_message_content !== void 0 ? _res_choices_at_message_content : \"\";\n}\n// To store message streaming controller\nconst ControllerPool = {\n    controllers: {},\n    addController (sessionIndex, messageId, controller) {\n        const key = this.key(sessionIndex, messageId);\n        this.controllers[key] = controller;\n        return key;\n    },\n    stop (sessionIndex, messageId) {\n        const key = this.key(sessionIndex, messageId);\n        const controller = this.controllers[key];\n        controller === null || controller === void 0 ? void 0 : controller.abort();\n    },\n    remove (sessionIndex, messageId) {\n        const key = this.key(sessionIndex, messageId);\n        delete this.controllers[key];\n    },\n    key (sessionIndex, messageIndex) {\n        return \"\".concat(sessionIndex, \",\").concat(messageIndex);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b0IsRUFBRUMsU0FBaUIsRUFBRTtRQUM1QyxNQUFNQyxNQUFNLElBQUksQ0FBQ0EsR0FBRyxDQUFDRixjQUFjQztRQUNuQyxNQUFNckMsYUFBYSxJQUFJLENBQUNrQyxXQUFXLENBQUNJLElBQUk7UUFDeEN0Qyx1QkFBQUEsd0JBQUFBLEtBQUFBLElBQUFBLFdBQVlJLEtBQUs7SUFDbkI7SUFFQW9DLFFBQU9KLFlBQW9CLEVBQUVDLFNBQWlCLEVBQUU7UUFDOUMsTUFBTUMsTUFBTSxJQUFJLENBQUNBLEdBQUcsQ0FBQ0YsY0FBY0M7UUFDbkMsT0FBTyxJQUFJLENBQUNILFdBQVcsQ0FBQ0ksSUFBSTtJQUM5QjtJQUVBQSxLQUFJRixZQUFvQixFQUFFSyxZQUFvQixFQUFFO1FBQzlDLE9BQU8sR0FBbUJBLE9BQWhCTCxjQUFhLEtBQWdCLE9BQWJLO0lBQzVCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcmVxdWVzdHMudHM/OTIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENoYXRSZXF1ZXN0LCBDaGF0UmVwb25zZSB9IGZyb20gXCIuL2FwaS9vcGVuYWkvdHlwaW5nXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2UsIE1vZGVsQ29uZmlnLCB1c2VBY2Nlc3NTdG9yZSwgdXNlQ2hhdFN0b3JlIH0gZnJvbSBcIi4vc3RvcmVcIjtcclxuaW1wb3J0IHsgc2hvd1RvYXN0IH0gZnJvbSBcIi4vY29tcG9uZW50cy91aS1saWJcIjtcclxuXHJcbmNvbnN0IFRJTUVfT1VUX01TID0gMzAwMDA7XHJcblxyXG5jb25zdCBtYWtlUmVxdWVzdFBhcmFtID0gKFxyXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW10sXHJcbiAgb3B0aW9ucz86IHtcclxuICAgIGZpbHRlckJvdD86IGJvb2xlYW47XHJcbiAgICBzdHJlYW0/OiBib29sZWFuO1xyXG4gIH0sXHJcbik6IENoYXRSZXF1ZXN0ID0+IHtcclxuICBsZXQgc2VuZE1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKCh2KSA9PiAoe1xyXG4gICAgcm9sZTogdi5yb2xlLFxyXG4gICAgY29udGVudDogdi5jb250ZW50LFxyXG4gIH0pKTtcclxuXHJcbiAgaWYgKG9wdGlvbnM/LmZpbHRlckJvdCkge1xyXG4gICAgc2VuZE1lc3NhZ2VzID0gc2VuZE1lc3NhZ2VzLmZpbHRlcigobSkgPT4gbS5yb2xlICE9PSBcImFzc2lzdGFudFwiKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1vZGVsQ29uZmlnID0geyAuLi51c2VDaGF0U3RvcmUuZ2V0U3RhdGUoKS5jb25maWcubW9kZWxDb25maWcgfTtcclxuXHJcbiAgLy8gQDMzMTg4NjgyMDogd29udCBzZW5kIG1heF90b2tlbnMsIGJlY2F1c2UgaXQgaXMgbm9uc2Vuc2UgZm9yIE11Z2dsZXNcclxuICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgZGVsZXRlIG1vZGVsQ29uZmlnLm1heF90b2tlbnM7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBtZXNzYWdlczogc2VuZE1lc3NhZ2VzLFxyXG4gICAgc3RyZWFtOiBvcHRpb25zPy5zdHJlYW0sXHJcbiAgICAuLi5tb2RlbENvbmZpZyxcclxuICB9O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0SGVhZGVycygpIHtcclxuICBjb25zdCBhY2Nlc3NTdG9yZSA9IHVzZUFjY2Vzc1N0b3JlLmdldFN0YXRlKCk7XHJcbiAgbGV0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuXHJcbiAgaWYgKGFjY2Vzc1N0b3JlLmVuYWJsZWRBY2Nlc3NDb250cm9sKCkpIHtcclxuICAgIGhlYWRlcnNbXCJhY2Nlc3MtY29kZVwiXSA9IGFjY2Vzc1N0b3JlLmFjY2Vzc0NvZGU7XHJcbiAgfVxyXG5cclxuICBpZiAoYWNjZXNzU3RvcmUudG9rZW4gJiYgYWNjZXNzU3RvcmUudG9rZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgaGVhZGVyc1tcInRva2VuXCJdID0gYWNjZXNzU3RvcmUudG9rZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGVhZGVycztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RPcGVuYWlDbGllbnQocGF0aDogc3RyaW5nKSB7XHJcbiAgcmV0dXJuIChib2R5OiBhbnksIG1ldGhvZCA9IFwiUE9TVFwiKSA9PlxyXG4gICAgZmV0Y2goXCIvYXBpL29wZW5haT9fdmVyY2VsX25vX2NhY2hlPTFcIiwge1xyXG4gICAgICBtZXRob2QsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIC4uLmdldEhlYWRlcnMoKSxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogYm9keSAmJiBKU09OLnN0cmluZ2lmeShib2R5KSxcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdENoYXQobWVzc2FnZXM6IE1lc3NhZ2VbXSkge1xyXG4gIGNvbnN0IHJlcTogQ2hhdFJlcXVlc3QgPSBtYWtlUmVxdWVzdFBhcmFtKG1lc3NhZ2VzLCB7IGZpbHRlckJvdDogdHJ1ZSB9KTtcclxuXHJcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdE9wZW5haUNsaWVudChcInYxL2NoYXQvY29tcGxldGlvbnNcIikocmVxKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHJlcy5qc29uKCkpIGFzIENoYXRSZXBvbnNlO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW1JlcXVlc3QgQ2hhdF0gXCIsIGVycm9yLCByZXMuYm9keSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFVzYWdlKCkge1xyXG4gIGNvbnN0IGZvcm1hdERhdGUgPSAoZDogRGF0ZSkgPT5cclxuICAgIGAke2QuZ2V0RnVsbFllYXIoKX0tJHsoZC5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIil9LSR7ZFxyXG4gICAgICAuZ2V0RGF0ZSgpXHJcbiAgICAgIC50b1N0cmluZygpXHJcbiAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9YDtcclxuICBjb25zdCBPTkVfREFZID0gMiAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIE9ORV9EQVkpO1xyXG4gIGNvbnN0IHN0YXJ0T2ZNb250aCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgMSk7XHJcbiAgY29uc3Qgc3RhcnREYXRlID0gZm9ybWF0RGF0ZShzdGFydE9mTW9udGgpO1xyXG4gIGNvbnN0IGVuZERhdGUgPSBmb3JtYXREYXRlKG5vdyk7XHJcblxyXG4gIGNvbnN0IFt1c2VkLCBzdWJzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgIHJlcXVlc3RPcGVuYWlDbGllbnQoXHJcbiAgICAgIGBkYXNoYm9hcmQvYmlsbGluZy91c2FnZT9zdGFydF9kYXRlPSR7c3RhcnREYXRlfSZlbmRfZGF0ZT0ke2VuZERhdGV9YCxcclxuICAgICkobnVsbCwgXCJHRVRcIiksXHJcbiAgICByZXF1ZXN0T3BlbmFpQ2xpZW50KFwiZGFzaGJvYXJkL2JpbGxpbmcvc3Vic2NyaXB0aW9uXCIpKG51bGwsIFwiR0VUXCIpLFxyXG4gIF0pO1xyXG5cclxuICBjb25zdCByZXNwb25zZSA9IChhd2FpdCB1c2VkLmpzb24oKSkgYXMge1xyXG4gICAgdG90YWxfdXNhZ2U/OiBudW1iZXI7XHJcbiAgICBlcnJvcj86IHtcclxuICAgICAgdHlwZTogc3RyaW5nO1xyXG4gICAgICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHRvdGFsID0gKGF3YWl0IHN1YnMuanNvbigpKSBhcyB7XHJcbiAgICBoYXJkX2xpbWl0X3VzZD86IG51bWJlcjtcclxuICB9O1xyXG5cclxuICBpZiAocmVzcG9uc2UuZXJyb3IgJiYgcmVzcG9uc2UuZXJyb3IudHlwZSkge1xyXG4gICAgc2hvd1RvYXN0KHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJlc3BvbnNlLnRvdGFsX3VzYWdlKSB7XHJcbiAgICByZXNwb25zZS50b3RhbF91c2FnZSA9IE1hdGgucm91bmQocmVzcG9uc2UudG90YWxfdXNhZ2UpIC8gMTAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHVzZWQ6IHJlc3BvbnNlLnRvdGFsX3VzYWdlLFxyXG4gICAgc3Vic2NyaXB0aW9uOiB0b3RhbC5oYXJkX2xpbWl0X3VzZCxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdENoYXRTdHJlYW0oXHJcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXSxcclxuICBvcHRpb25zPzoge1xyXG4gICAgZmlsdGVyQm90PzogYm9vbGVhbjtcclxuICAgIG1vZGVsQ29uZmlnPzogTW9kZWxDb25maWc7XHJcbiAgICBvbk1lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcsIGRvbmU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgICBvbkVycm9yOiAoZXJyb3I6IEVycm9yLCBzdGF0dXNDb2RlPzogbnVtYmVyKSA9PiB2b2lkO1xyXG4gICAgb25Db250cm9sbGVyPzogKGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcikgPT4gdm9pZDtcclxuICB9LFxyXG4pIHtcclxuICBjb25zdCByZXEgPSBtYWtlUmVxdWVzdFBhcmFtKG1lc3NhZ2VzLCB7XHJcbiAgICBzdHJlYW06IHRydWUsXHJcbiAgICBmaWx0ZXJCb3Q6IG9wdGlvbnM/LmZpbHRlckJvdCxcclxuICB9KTtcclxuXHJcbiAgY29uc29sZS5sb2coXCJbUmVxdWVzdF0gXCIsIHJlcSk7XHJcblxyXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgY29uc3QgcmVxVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIFRJTUVfT1VUX01TKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFwiL2FwaS9jaGF0LXN0cmVhbVwiLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICBwYXRoOiBcInYxL2NoYXQvY29tcGxldGlvbnNcIixcclxuICAgICAgICAuLi5nZXRIZWFkZXJzKCksXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcSksXHJcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXHJcbiAgICB9KTtcclxuICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0SWQpO1xyXG5cclxuICAgIGxldCByZXNwb25zZVRleHQgPSBcIlwiO1xyXG5cclxuICAgIGNvbnN0IGZpbmlzaCA9ICgpID0+IHtcclxuICAgICAgb3B0aW9ucz8ub25NZXNzYWdlKHJlc3BvbnNlVGV4dCwgdHJ1ZSk7XHJcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHJlcy5vaykge1xyXG4gICAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keT8uZ2V0UmVhZGVyKCk7XHJcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuXHJcbiAgICAgIG9wdGlvbnM/Lm9uQ29udHJvbGxlcj8uKGNvbnRyb2xsZXIpO1xyXG5cclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAvLyBoYW5kbGUgdGltZSBvdXQsIHdpbGwgc3RvcCBpZiBubyByZXNwb25zZSBpbiAxMCBzZWNzXHJcbiAgICAgICAgY29uc3QgcmVzVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBmaW5pc2goKSwgVElNRV9PVVRfTVMpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkZXI/LnJlYWQoKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQocmVzVGltZW91dElkKTtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUoY29udGVudD8udmFsdWUpO1xyXG4gICAgICAgIHJlc3BvbnNlVGV4dCArPSB0ZXh0O1xyXG5cclxuICAgICAgICBjb25zdCBkb25lID0gIWNvbnRlbnQgfHwgY29udGVudC5kb25lO1xyXG4gICAgICAgIG9wdGlvbnM/Lm9uTWVzc2FnZShyZXNwb25zZVRleHQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZmluaXNoKCk7XHJcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQW5hdXRob3JpemVkXCIpO1xyXG4gICAgICBvcHRpb25zPy5vbkVycm9yKG5ldyBFcnJvcihcIkFuYXV0aG9yaXplZFwiKSwgcmVzLnN0YXR1cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiU3RyZWFtIEVycm9yXCIsIHJlcy5ib2R5KTtcclxuICAgICAgb3B0aW9ucz8ub25FcnJvcihuZXcgRXJyb3IoXCJTdHJlYW0gRXJyb3JcIiksIHJlcy5zdGF0dXMpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIk5ldFdvcmsgRXJyb3JcIiwgZXJyKTtcclxuICAgIG9wdGlvbnM/Lm9uRXJyb3IoZXJyIGFzIEVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXF1ZXN0V2l0aFByb21wdChtZXNzYWdlczogTWVzc2FnZVtdLCBwcm9tcHQ6IHN0cmluZykge1xyXG4gIG1lc3NhZ2VzID0gbWVzc2FnZXMuY29uY2F0KFtcclxuICAgIHtcclxuICAgICAgcm9sZTogXCJ1c2VyXCIsXHJcbiAgICAgIGNvbnRlbnQ6IHByb21wdCxcclxuICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgfSxcclxuICBdKTtcclxuXHJcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdENoYXQobWVzc2FnZXMpO1xyXG5cclxuICByZXR1cm4gcmVzPy5jaG9pY2VzPy5hdCgwKT8ubWVzc2FnZT8uY29udGVudCA/PyBcIlwiO1xyXG59XHJcblxyXG4vLyBUbyBzdG9yZSBtZXNzYWdlIHN0cmVhbWluZyBjb250cm9sbGVyXHJcbmV4cG9ydCBjb25zdCBDb250cm9sbGVyUG9vbCA9IHtcclxuICBjb250cm9sbGVyczoge30gYXMgUmVjb3JkPHN0cmluZywgQWJvcnRDb250cm9sbGVyPixcclxuXHJcbiAgYWRkQ29udHJvbGxlcihcclxuICAgIHNlc3Npb25JbmRleDogbnVtYmVyLFxyXG4gICAgbWVzc2FnZUlkOiBudW1iZXIsXHJcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXHJcbiAgKSB7XHJcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleShzZXNzaW9uSW5kZXgsIG1lc3NhZ2VJZCk7XHJcbiAgICB0aGlzLmNvbnRyb2xsZXJzW2tleV0gPSBjb250cm9sbGVyO1xyXG4gICAgcmV0dXJuIGtleTtcclxuICB9LFxyXG5cclxuICBzdG9wKHNlc3Npb25JbmRleDogbnVtYmVyLCBtZXNzYWdlSWQ6IG51bWJlcikge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXkoc2Vzc2lvbkluZGV4LCBtZXNzYWdlSWQpO1xyXG4gICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcnNba2V5XTtcclxuICAgIGNvbnRyb2xsZXI/LmFib3J0KCk7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlKHNlc3Npb25JbmRleDogbnVtYmVyLCBtZXNzYWdlSWQ6IG51bWJlcikge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXkoc2Vzc2lvbkluZGV4LCBtZXNzYWdlSWQpO1xyXG4gICAgZGVsZXRlIHRoaXMuY29udHJvbGxlcnNba2V5XTtcclxuICB9LFxyXG5cclxuICBrZXkoc2Vzc2lvbkluZGV4OiBudW1iZXIsIG1lc3NhZ2VJbmRleDogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gYCR7c2Vzc2lvbkluZGV4fSwke21lc3NhZ2VJbmRleH1gO1xyXG4gIH0sXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJ1c2VBY2Nlc3NTdG9yZSIsInVzZUNoYXRTdG9yZSIsInNob3dUb2FzdCIsIlRJTUVfT1VUX01TIiwibWFrZVJlcXVlc3RQYXJhbSIsIm1lc3NhZ2VzIiwib3B0aW9ucyIsInNlbmRNZXNzYWdlcyIsIm1hcCIsInYiLCJyb2xlIiwiY29udGVudCIsImZpbHRlckJvdCIsImZpbHRlciIsIm0iLCJtb2RlbENvbmZpZyIsImdldFN0YXRlIiwiY29uZmlnIiwibWF4X3Rva2VucyIsInN0cmVhbSIsImdldEhlYWRlcnMiLCJhY2Nlc3NTdG9yZSIsImhlYWRlcnMiLCJlbmFibGVkQWNjZXNzQ29udHJvbCIsImFjY2Vzc0NvZGUiLCJ0b2tlbiIsImxlbmd0aCIsInJlcXVlc3RPcGVuYWlDbGllbnQiLCJwYXRoIiwiYm9keSIsImZldGNoIiwibWV0aG9kIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcXVlc3RDaGF0IiwicmVxIiwicmVzIiwicmVzcG9uc2UiLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwicmVxdWVzdFVzYWdlIiwiZm9ybWF0RGF0ZSIsImQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImdldERhdGUiLCJPTkVfREFZIiwibm93IiwiRGF0ZSIsInN0YXJ0T2ZNb250aCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJ1c2VkIiwic3VicyIsIlByb21pc2UiLCJhbGwiLCJ0b3RhbCIsInR5cGUiLCJtZXNzYWdlIiwidG90YWxfdXNhZ2UiLCJNYXRoIiwicm91bmQiLCJzdWJzY3JpcHRpb24iLCJoYXJkX2xpbWl0X3VzZCIsInJlcXVlc3RDaGF0U3RyZWFtIiwibG9nIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInJlcVRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInJlc3BvbnNlVGV4dCIsImZpbmlzaCIsIm9uTWVzc2FnZSIsIm9rIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwib25Db250cm9sbGVyIiwicmVzVGltZW91dElkIiwicmVhZCIsInRleHQiLCJkZWNvZGUiLCJ2YWx1ZSIsImRvbmUiLCJzdGF0dXMiLCJvbkVycm9yIiwiRXJyb3IiLCJlcnIiLCJyZXF1ZXN0V2l0aFByb21wdCIsInByb21wdCIsImNvbmNhdCIsImRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsImNob2ljZXMiLCJhdCIsIkNvbnRyb2xsZXJQb29sIiwiY29udHJvbGxlcnMiLCJhZGRDb250cm9sbGVyIiwic2Vzc2lvbkluZGV4IiwibWVzc2FnZUlkIiwia2V5Iiwic3RvcCIsInJlbW92ZSIsIm1lc3NhZ2VJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/requests.ts\n"));

/***/ })

});